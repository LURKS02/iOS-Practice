# 위임 패턴(Delegate Pattern)

클래스나 구조체가 특정한 일을 다른 타입에게 위임하는 것을 허용하는 패턴<br>
일부 기능을 책임지는 부분을 재사용 가능한 코드로 캡슐화하는데 유용하게 쓰인다.<br>

### 객체 합성
클래스 상속에 대한 대안으로, 다른 객체를 여러 개 붙여서 새로운 기능/객체를 구성하는 것 <br>
객체 또는 데이터 유형을 더 복잡한 유형으로 결합하는 방법<br>
한 객체가 다른 객체에 대한 참조자를 얻는 방식으로, 런타임에 동적으로 정의<br>
각 클래스의 캡슐화를 유지할 수 있고, 각 클래스의 한 가지 작업에 집중할 수 있다.<br>
재사용을 위하여 새로운 구성 요소를 생성할 필요 없이 기존의 구성 요소를 조립해서 새로운 기능을 획득할 수 있다.<br>
그러나 가능한 구성 요소의 집합이 실제로 사용할 수 있을 만큼 충분하지 않아 조합을 통한 재사용만으로 목적을 달성하는 경우는 드물다.<br>

#### 화이트박스 / 블랙박스 재사용
- 화이트박스 재사용(white-box reuse)
서브 클래싱에 의한 재사용<br>
상속을 받으면 부모 클래스의 내부가 서브 클래스에 공개되므로 내부를 볼 수 있다는 의미인 “화이트박스”를 쓴다.<br>
- 블랙박스 재사용(black-box reuse)
객체 합성을 통한 재사용<br>
객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문에 “블랙박스”를 쓴다.<br>

#### 클래스 상속의 장단점
- 장점
컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용할 수 있다.<br>
클래스 상속으로 부모 클래스 구현을 쉽게 수정할 수 있고, 모든 연산이 아닌 일부만 재정의도 가능하다.<br>

- 단점
상속은 컴파일 시점에 결정되는 사항이므로 런타임에 상속받은 부모 클래스의 구현을 변경할 수 없다.<br>
부모 클래스의 구현이 서브 클래스에서 전부 드러나므로 캡슐화를 파괴한다고 보는 시각도 있다. <br>
서브 클래스는 부모 클래스의 구현에 종속되므로, 부모 클래스 구현에 변화가 생기면 서브 클래스도 변경해야 한다.<br>
서브 클래스를 재사용하려고 할 때, 상속한 구현이 새로운 문제에 맞지 않거나 부모 클래스를 재작성 또는 다른 것으로 대체해야하는 경우가 발생하여 구현의 종속성이 생기고 유연성과 재사용성을 떨어뜨린다.<br>
(추상 클래스에는 구현이 거의 없으므로 추상 클래스에서만 상속받는 방법도 있다.)<br>

<br>

### 위임(delegation)
프로토콜을 통해 정의된 메서드를 구현하는 특정 객체가 있을 때, 해당 객체에 특정 작업을 위임하는 것을 가능하게 하는 방식<br>
두 객체가 하나의 요청을 처리할 때, 수신 객체가 연산의 처리를 위임자(delegate)에게 보낸다. (서브클래스가 부모클래스에게 요청을 전달하는 것과 유사)<br>
수신 객체는 대리자에게 자신을 매개변수로 전달하여 위임된 연산이 수신자를 참조하도록 한다.<br>

```kotlin
class Rectangle(val width: Int, val height: Int) {
	fun area() = width * height
}

class Window(val bounds: Rectangle) {
	fun area() = bounds.area()
}
```

위 코드에서는 Window 클래스를 Rectangle 클래스의 서브 클래스로 만드는 대신, Rectangle 클래스를 자신의 인스턴스 변수로 만들고 Rectangle 클래스에 정의된 행동이 필요해지면 Rectangle 클래스에 위임하여 Rectangle의 행동을 재사용한다.<br>

- 장점
런타임에 행동의 복합을 가능하게 하며, 복합하는 방식도 변경할 수 있다. (런타임에 Rectangle 인스턴스가 아니라 Circle 인스턴스로 대체할 수 있다.)
- 단점
클래스에 상호작용이 다 정의되어 있지 않고 런타임 객체에 따라서 결과가 다르기 때문에, 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기가 어렵다.<br>
위임은 고도로 표준화된 패턴에서 사용해야 최상의 효과를 얻을 수 있다.<br>

#### 위임을 사용하는 디자인 패턴
1. 상태(State) 패턴 : 객체는 현재 상태를 표현하는 상태 객체에 요청의 처리를 위임한다.
2. 전략(Strategy) 패턴 : 객체는 요청을 수행하는 추상화된 전략 객체에게 특정 요청을 위임한다.
3. 방문자(Visitor) 패턴 : 객체 구조의 각 요소에 수행하는 연산은 언제나 방문자 객체에게 위임된 연산이다.
4. 중재자(Mediator) 패턴 : 객체 간의 교류를 중재하는 객체를 도입하여 중재자 객체가 다른 객체로 연산을 전달하도록 구현한다. 이때 연산에 자신에 대한 참조자를 함께 보내 위임받은 객체가 다시 자신에게 메시지를 보내 자신이 정의한 데이터를 얻어가도록 한다.
5. 책임 연쇄(Chain of Responsibility) 패턴 : 한 객체에서 다른 객체로 고리를 따라서 요청의 처리를 계속 위임하며, 해당 요청은 요청을 처음 받은 원본 객체에 대한 참조자를 포함한다.
6. 가교(Bridge) 패턴 : 구현과 추상적 개념을 분리하여 추상화와 특정 구현을 대응시키고, 추상화는 단순히 자신의 연산을 구현에 전달한다.



