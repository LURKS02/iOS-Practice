# 네트워크

### 웹 동작 방식

<img src="https://github.com/LURKS02/iOS-Practice/assets/63408930/8191e22f-ed22-41c7-901b-260dd98783cd" height="600px" width="800px">

1. 사용자가 브라우저에 URL 입력 <br>
2. 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음<br>
3. HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성<br>
4. TCP/IP 연결을 통해 HTTP 요청이 서버로 전송<br>
5. 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메시지를 생성<br>
6. TCP/IP 연결을 통해 요청한 컴퓨터로 전송<br>
7. 도착한 HTTP 응답 메시지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있는 형태가 됨<br>

<br>

### HTTP(Hyper Text Transfer Protocol)
서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜로, HTTP는 애플리케이션 레벨의 프로토콜로 TCP / IP 위에서 작동한다.<br>
HTTP는 상태를 가지고 있지 않는 Stateless 모델이며, Method / Path / Version / Headers / Body 등으로 구성된다.<br>

<br>

### HTTP 와 HTTPS
HTTP는 평문 데이터를 전송하는 프로토콜이므로, HTTP로 비밀번호 또는 주민번호 등을 주고 받으면 제 3자에 의해 조회될 위험이 있다.<br>
이러한 문제를 해결하기 위하여 HTTP에 암호화가 추가된 프로토콜이 HTTPS이다.<br>
대칭키 암호화와 비대칭키 암호화가 모두 사용된다.<br>
비대칭키 암/복호화는 비용이 매우 크기 떄문에, 서버-클라이언트가 주고 받는 모든 메시지를 비대칭키로 암호화하면 오버헤드가 발생할 위험이 있다.<br>
따라서 서버-클라이언트가 최초 1회로 서로 대칭키를 공유하기 위한 과정에서 비대칭키 암호화를 사용하며, 이후 메시지를 주고 받을 때는 대칭키 암호화를 사용한다.<br>
자세한 과정은 다음과 같다.<br>

<img src="https://github.com/LURKS02/iOS-Practice/assets/63408930/4e95c78a-b913-4899-95bb-2d75f45e0fc0)" height="1000px" width="600px">

1. 클라이언트가 서버로 최초 연결 시도
2. 서버가 공개키를 넘겨줌
3. 클라이언트가 인증서의 유효성을 검사하고 세션키를 발급
4. 서버는 암호화된 세션키를 개인키로 복호화하여 세션키를 얻음
5. 클라이언트-서버는 동일한 세션키를 공유하므로 데이터 전달 시 세션키로 암/복호화 진행

공개키로 암호화된 메시지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 서버를 제외한 누구도 원본 데이터를 얻을 수 없다.<br>

<br>

### TCP / HTTP
- HTTP는 비연결형 프로토콜, TCP는 연결형 프로토콜이다.<br>
- HTTP는 단방향 통신만 가능하며, TCP는 양방향 통신이 가능하다.<br>
- HTTP는 응용 계층 프로토콜 (7) 이며, TCP는 전송 계층 프로토콜 (4) 이다. <br>

<br>


### TCP / UDP
TCP는 연결형 서비스로, 3-way handshaking 과정을 통해 연결을 설정하며, 높은 신뢰성을 보장하지만 속도가 비교적 느리다는 단점이 존재한다.<br>
따라서 TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 사용된다.<br>
UDP는 비연결형 서비스로, 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지지만, 수신 여부를 확인하지 않기 때문에 속도가 빠르다.<br>
UDP는 실시간성이 중요한 스트리밍에 자주 사용된다.<br>

- TCP : 연결형 서비스(패킷 교환 방식), 전송 순서 보장, 수신 여부 확인, 1:1 통신, 신뢰성 높음, 속도 느림
- UDP : 비연결형 서비스(데이터그램 방식), 전송 순서가 바뀔 수 있음, 수신 여부를 확인하지 않음, 1:1 또는 1:N 또는 N:N 통신, 신뢰성 낮음, 속도 빠름

<br>

### 3-Way Handshaking
TCP 네트워크에서 통신을 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법<br>
송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태임을 확인하게 된다.<br>

<br>

### GET / POST
#### GET
데이터를 조회하기 위해 사용되는 방식으로, 데이터를 헤더에 추가하여 전송하는 방식<br>
URL에 데이터가 노출되기 떄문에 보안적으로 중요한 데이터를 포함해서는 안된다.<br>
#### POST
데이터를 추가 또는 수정하기 위해 사용되는 방식으로, 데이터를 바디에 추가하여 전송하는 방식<br>
URL에 데이터가 노출되지 않아 GET 보다는 안전하다.<br>

- GET : URL에 데이터 노출, 헤더에 데이터 위치, 캐싱 가능
- POST : URL에 데이터 노출되지 않음, 바디에 데이터 위치, 캐싱 불가능

<br>

### 공인 IP와 사설 IP
#### 공인 IP
전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소<br>
외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능하다.<br>
따라서 방화벽 등의 보아 설정을 해주어야 한다.<br>

#### 사설 IP
어떤 네트워크 안에서 사용되는 IP 주소<br>
IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소이다.<br>
별도 설정 없이는 외부에서 접근이 불가능하다.<br>

<br>

### OSI 7계층
- 7계층(응용 계층) : 사용자와 직접 상호작용 하는 응용 프로그램들이 포함된 계층
- 6계층(표현 계층) : 데이터의 형식(Format)을 정의하는 계층
- 5계층(세션 계층) : 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
- 4계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
- 3계층(네트워크 계층) : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
- 2계층(데이터 링크 계층) : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
- 1계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층

<br>

### HTTP1과 HTTP2
HTTP1은 연결 당 하나의 요청/응답을 처리하여 비효율적인 방식이었으며, RTT(Round Trip Time) 증가, 즉 패킷 왕복 시간의 지연이 발생하였다.<br>
HTTP1.1은 지속 연결(Persistence Connection)과 파이프라이닝 등으로 보완했지만 한계가 존재하였다.<br>
- HOL(Head of Line) Blocking : 클라이언트의 요청과 서버의 응답이 동기화되어 지연 발생(여러 요청을 동시에 보내지만, 첫 요청이 끝나지 않으면 나머지 요청도 블로킹 됨)
- 헤더 크기의 비대 : 연속된 요청에 대해 동일한 헤더를 전송하게 됨
  
HTTP2는 다음 기술을 사용하여 HTTP1의 성능 문제를 해결하였다. <br>
- Multiplexed Streams : 하나의 커넥션으로 여러 개의 메시지를 순서 상관없이 동시에 주고 받는다.<br>
- Stream Prioritization : 리소스 간 전송 우선 순위를 설정할 수 있다.<br>
- Header Compression : 헤더 정보를 HPACK 압축 방식을 사용하여 압축 전송하며, HPACK은 허프만을 사용한다.<br>
- Server Push : HTML문서 상에 필요한 리소스를 클라이언트 요청 없이 보내줄 수 있다.<br>

HTTP3는 다음의 특징을 가진다.<br>
- QUIC라는 계층 상에서 돌아가며, 이는 UDP를 기반으로 돌아가 RTT가 감소하였다.<br>
- 순방향 오류 수정 매커니즘(FEC, Forward Error Correction)으로 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식<br>

