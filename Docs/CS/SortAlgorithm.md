# Sort Algorithm

### Bubble Sort
서로 인접한 두 원소를 비교하여 정렬하는 알고리즘<br>
0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬하며, 시간복잡도는 O(n^2)이다.<br>

<br>

### Heap Sort
주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘<br>
전체를 정렬하는 것이 아니라 가장 큰 값 몇 개만을 필요로 하는 경우 유용하며, O(nlog2n)의 시간복잡도를 가진다.<br>

<br>

### Merge Sort
주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할 정복 알고리즘<br>
시간복잡도는 O(nlog2n)이며, 정렬된 두개의 리스트를 합병(merge)하며 배열을 정렬해나간다.<br>

<br>

### Quick Sort
매우 빠른 속도의 분할 정복 알고리즘 중 하나로, Merge Sort와는 다르게 리스트를 비균등하게 분할한다.<br>
Pivot을 설정한 뒤, Pivot보다 큰 값과 작은 값으로 분할하여 정렬한다.<br>
시간복잡도는 O(nlog2n)이며, 리스트가 계속해서 불균등하게 나눠지는 경우(최악) 시간복잡도는 O(n^2)까지 나빠질 수 있다.<br> 


### * n개의 배열에서 k(k <= n)번째 큰 수를 찾는 알고리즘

이러한 문제는 일반적으로 퀵정렬을 사용하지만, 이 경우 정렬이 불필요한 부분들을 정렬하게 되기도 한다.<br>

#### 퀵선택 알고리즘
퀵정렬을 한 후 pivot과 k를 비교하여 다음과 같이 수행한다.<br>
- pivot의 인덱스가 k와 같은 경우 : 그대로 인덱스의 값 리턴
- pivot의 인덱스가 k보다 작은 경우 : pivot의 인덱스 + 1부터 마지막 인덱스까지 다시 Partition함수에 넘겨준다.
- pivot의 인덱스가 k보다 큰 경우 : 첫번째 인덱스부터 pivot의 인덱스 - 1까지 다시 Partition함수에 넘겨준다.

예를 들어 pivot의 인덱스가 7이고, k가 5라면 pivot의 오른쪽 부분은 재귀 함수를 돌지 않아 한 쪽만으로 재귀를 진행하게 된다.<br>
따라서 퀵선택 알고리즘의 시간복잡도는 n + n/2 + n/4 + … + 1 = O(n)이다.<br>

<br>

### Insertion Sort
두 번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘<br>
평균 시간복잡도는 O(n^2)이지만, 가장 빠른 경우 O(n)까지 높아질 수 있다.<br>
