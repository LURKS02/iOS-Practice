# OS

### Byte Ordering
데이터가 저장되는 순서<br>

#### Big Endian
MSB가 가장 낮은 주소에 위치하는 저장 방식<br>
네트워크에서 데이터를 전송할 때 주로 사용된다.<br>
가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악할 수 있다.<br>

#### Little Endian
MSB가 가장 높은 주소에 위치하는 저장 방식<br>
마이크로프로세서에서 주로 사용된다.<br>
가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산을 할 수 있다.<br>

<br>

### 동시성과 병렬성
#### 동시성
논리적으로 동시에 수행될 수 있는 성질<br>
#### 병렬성
물리적으로 동시에 수행될 수 있는 성질<br>

어떤 작업을 범위를 나누어 4개의 쓰레드로 쿼드 코어에서 실행시킨다면, 이는 동시성과 병렬성을 동시에 갖는다고 할 수 있다.<br>
반대로 이것을 싱글 코어에서 돌린다면, 동시성은 갖지만 병렬성을 갖지는 못한다.<br>
하지만 하나의 코어는 여러 개의 파이프라인으로 처리되므로, 서로 다른 명령을 동시에 처리할 수 있는 상황이라면 하나의 코어임에도 병렬적으로 실행될 수 있다.<br>


<br>

### Context Switching
interrupt를 발생시켜 CPU에서 실행중인 프로세스를 중단하고 다른 프로세스를 처리하기 위한 과정<br>
현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후 이전에 저장된 프로세스의 상태를 다시 복구한다.<br>
interrupt란, CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요함을 CPU에게 알리는 것을 의미한다.<br>

<br>

### 프로세스와 쓰레드
#### Process
메모리에 올라와 실행되고 있는 프로그램의 인스턴스<br>
운영체제로부터 독립된 메모리 영역을 할당받는다. (다른 프로세스의 자원에 접근할 수 없다.)<br>
프로세스들은 독립적이기 때문에 통신하기 위하여 IPC를 사용해야 한다.<br>
프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.<br>

#### Thread
프로세스 내에서 할당받은 자원을 이용하여 동작하는 실행 단위<br>
쓰레드는 프로세스 내에서 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유한다.<br>
Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하게 되면 LIFO 구조에 의해 실행 순서가 복잡해지므로 실행 흐름을 원활하게 만들기 위하여 Stack을 따로 분리한 것이다.<br>
쓰레드는 프로세스의 자원을 공유하므로, 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.<br> 
<br>

### 멀티 프로세스와 쓰레드
#### Multi Process
하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것<br>
1개의 프로세스가 죽어도 자식 프로세스 외의 다른 프로세스들은 계속 실행된다.<br>
Context Switching을 위한 오버헤드 (캐시 초기화, 인터럽트 등)가 발생한다.<br>
프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신이 어렵다.<br>

#### Multi Thread
하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것 <br>
프로세스를 위해 자원을 할당하는 시스템 콜이나 Context Switching의 오버헤드를 줄일 수 있다.<br>
쓰레드는 메모리를 공유하므로 통신이 쉽고 자원을 효율적으로 사용할 수 있지만, 하나의 쓰레드에 문제가 생기면 전체 프로세스가 영향을 받을 수 있다.<br>
여러 개의 쓰레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화) 문제가 발생할 수 있다.<br>

<br>

### 레이스 컨디션
둘 이상의 실행 주체가 동시에 하나의 자원에 접근하기 위해 경쟁하는 상태<br>
레이스 컨디션에 의해 자원의 동기화 문제 / 교착 상태 / 프로세스 충돌 등의 문제가 발생할 수 있다.<br>

<br>

### DeadLock & Critical Section
#### DeadLock (교착 상태)
한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로, 프로세스가 자원을 얻기 위해 영구적으로 기다리는 상태<br>
#### Critical Section (임계 영역)
둘 이상의 실행 주체가 동시에 접근해서는 안되는 영역<br>

<br>

### Semaphore & Mutex
#### Semaphore
- 리소스에 동시 허용이 가능한 쓰레드의 수를 제어하는 데 사용된다.<br>
- 소유 권한이 없으므로, 잠금을 획득하지 않은 쓰레드도 signal 연산을 사용하여 잠금을 해제할 수 있다.<br>
- 초기 값을 설정할 수 있으며, 허용 가능한 동시 엑세스 수를 나타낸다.<br>
- wait(P)와 signal(V)연산을 통해 제어된다.<br>

#### Mutex
- 임계 영역을 보호하여 데이터 무결성을 보장하기 위해서 사용된다.<br>
- 소유 권한을 가지므로, 잠금을 획득한 쓰레드만 잠금을 해제할 수 있다.<br>
- 주로 이진 세마포어(Binary Semaphore)로 초기화되며, 두 가지 상태(잠금 상태와 잠금 해제 상태)만 가진다.<br>
- lock과 unlock 연산을 통해서 제어된다.<br>

<br>

### CPU 메모리 I/O 도중 생기는 병목 현상 해결법
메모리를 계층화하여 병목 현상을 해결하고, 자주 접근하는 데이터의 경우 캐시에 저장하여 접근 속도를 향상시킴으로써 부하를 줄일 수 있다.<br>

<br>

### Virtual Memory
RAM의 부족한 용량을 보완하기 위하여 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식<br>
컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여, 사용하는 사용자들에게 매우 큰 메모리로 보여지게 한다.<br>
OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 테이블에 기록한다.<br>
CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하고, 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러오고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하게 된다. (스와핑) <br>
가상 주소는 메모리 관리 장치에 의하여 실제 주소로 변환되며, 이 덕분에 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있다.<br>
가상메모리는 가상 주소와 실제 주소가 매핑되어 있는, 프로세스의 주소 정보가 들어있는 페이지 테이블로 관리되며, 속도 향상을 위해 캐시(TLB)를 사용할 수 있다.<br>

<br>

### Page Fault
가상 메모리를 사용하면서, 실제 메모리에 원하는 페이지가 없는 상황이 생길 수 있다.<br>
즉 가상 메모리에는 존재하지만, 실제 메모리에 없는 데이터나 코드에 접근할 경우 발생하는 에러를 말한다.<br>
가상 메모리는 하드디스크에 저장되어 있기 때문에 디스크로부터 읽어와야 하는데, 디스크 I/O에 의한 속도의 저하가 발생할 수 있다.<br>

<br>

### 페이지 교체 알고리즘
#### LRU(Least Recently Used)
페이지를 교체하기 위한 알고리즘 중 하나로, 페이지를 교체하는 이유는 가상 메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문이다. <br>
페이지 교체를 위해서는 실제 메모리에 존재하는 페이지를 가상 메모리로 저장한 후, 가상 메모리에서 조회한 페이지를 실제 메모리로 로드해야 한다.<br>
이때 어떤 실제 메모리의 페이지를 가상 메모리로 희생시킬 것이냐에 대한 문제가 발생하는데, 이때 사용하는 알고리즘 중 하나가 LRU이다.<br>
이는 실제 메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식이다.<br>
그 외에도 먼저 적재된 페이지를 희생시키는 FIFO(First In First Out) 알고리즘 또는 LRU 알고리즘을 응용하여 페이지에 Second-Change를 주는 LRU Approximation 등이 있다.<br>

<br>

### OS 스케줄러
시스템의 자원은 제한적으로, 한정된 자원을 여러 프로세스가 효율적으로 사용할 수 있도록 운영체제가 할당해줄 수 있게 하는 역할을 하는 것이 스케줄러이다.<br>
프로세스를 스케줄링하기 위해서는 3가지 종류의 큐가 사용된다.<br>
- Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue : 현재 메모리 내에 있으면서 CPU를 할당받기를 기다리는 프로세스의 집합
- Device Queue : Device I/O 작업을 대기하는 프로세스의 집합

또한 스케줄러의 종류는 다음과 같다.<br>
- 장기 스케줄러(작업 스케줄러)
이때 디스크에서 어떤 프로그램을 가져와 준비 큐에 등록할지 결정한다.<br>
수십 초 내지 수 분 단위로 가끔 호출되므로 상대적으로 느린 속도를 허용한다.<br>
- 단기 스케줄러(CPU 스케줄러)
스케줄링 알고리즘에 따라 CPU를 할당할 프로세스를 선택한다.<br>
ms이하의 시간 단위로 매우 빈번하게 호출되므로 수행 속도가 충분히 빨라야 한다.<br>
- 중기 스케줄러
메모리에 적재된 프로세스의 수를 동적으로 조절하기 위하여 추가된 스케줄러<br>
메모리에 올라와 있는 프로세스 중 일부의 메모리를 디스크에 저장한다.<br>



