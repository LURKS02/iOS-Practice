# 데이터베이스

### Index
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조<br>
예를 들어 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는 것은 오랜 시간이 걸리기 때문에 책의 색인을 추가한다.<br>
데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에, 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 한다.<br>
만약 Index를 적용하지 않은 컬럼을 조회한다면, 전체를 탐색하는 Full Scan이 수행되는데 이는 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.<br>

#### 해시 테이블
컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.<br>
시간복잡도가 O(1)로 검색이 매우 빠르지만, 부등호와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.<br>

#### B+Tree
자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.<br>
BTree의 리프 노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.<br>
해시 테이블보다 나쁜 O(log2n)의 시간복잡도를 가지지만 해시 테이블보다 흔하게 사용된다.<br>

<br>

### DB 정규화
#### 제1정규형
모든 속성 값이 원자 값을 갖도록 분해한다.<br>
#### 제2정규형
제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.<br>
(완전 함수 종속 : 기본키의 부분 집합이 다른 값을 결정하지 않는 것)
#### 제3정규형
제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해한다.<br>
(이행적 종속이란 A->B->C가 성립하는 것으로, 이를 A와 B, B와 C로 분해하는 것)
#### BCNF 정규형
제3정규형을 만족하고, 함수 종속성 X -> Y 가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.<br>

<br>

### Transaction
데이터베이스 작업의 단위로써, 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법<br>

#### Transaction의 ACID
- 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.<br>
- 일관성(Consistency) : 트랜잭션을 수행하기 전후 데이터베이스는 항상 일관된 상태를 유지해야 한다.<br>
- 고립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하지 않아야 한다.<br>
- 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.<br>

<br>

### 낙관적 / 비관적 동시성 제어
#### 낙관적 동시성 제어
사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정<br>
잠금을 사용하지 않는 대신 레코드 버전 등을 통해 수정 시점에 변경 여부를 검사<br>

#### 비관적 동시성 제어
사용자들이 같은 데이터를 동시에 수정할 것이라고 가정<br>
공유락/베타락 등의 잠금을 사용하는 방식으로, 시스템의 동시성을 심각하게 떨어뜨릴 수 있어 wait / nowait 옵션과 함께 사용해야 한다.<br>

<br>

### DB Lock
여러 개의 트랜잭션들이 하나의 데이터로 동시 접근하려고 할 때 제어해주는 도구<br>
- 공유락(LS, Shared Lock) : 트랜잭션이 읽기를 할 때 사용하는 락으로, 데이터를 읽을 수는 있지만 쓸 수 없다. 
- 베타락(LX, Exclusive Lock) : 트랜잭션이 읽고 쓰기를 할 때 사용하는 락으로, 데이터를 읽고 쓸 수 있다.

<br>

### 커넥션 풀
커넥션은 TCP/IP 연결에 의한 3-Way Handshaking이 발생하여 연결에 오랜 시간이 걸리지만, 이를 초기에 한 번 생성해두고 관리하면 재사용이 가능하다.<br>
애플리케이션 초기에 이러한 커넥션들을 모아놓은 곳이 커넥션 풀이다.<br>
멀티 쓰레드 환경에서는 각 쓰레드가 커넥션 풀을 점유하여 사용하는데, 커넥션 풀에 커넥션이 부족한 상황에서 커넥션을 요청하게 되면 커넥션 풀이 반환될 때까지 기다려야 하므로 커넥션 풀이 바닥나지 않도록 주의해야 한다.<br>

<br>

### RDBMS & NoSQL
#### RDBMS
2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스<br>
스키마에 맞추어 데이터를 관리하므로, 데이터의 정합성을 보장할 수 있다.<br>
시스템이 커질수록 쿼리가 복잡해지고 성능이 저하되며, 수평적인 확장이 어렵다.<br>

#### NoSQL
RDBMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장한 데이터베이스<br>
NoSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭다.<br>
중복 데이터 추가가 가능하므로, 이에 대한 관리가 필요하다.<br>

<br>

### 힌트(Hint)
SQL을 튜닝하기 위한 지시구문<br>
옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우 개발자가 직접 최적의 실행 계획을 제공하는 것이다.<br>
```
SELECT [힌트절 : PARALLEL, INDEX, FULL 등…]
```

<br>

### Clustering & Replication

#### Clustering
여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식<br>
동기 방식으로 노드들 간의 데이터를 동기화한다.<br>
1개의 노드가 죽어도 다른 노드가 살아있어 시스템을 장애 없이 운영할 수 있다.<br>
여러 노드들 간의 데이터를 동기화시키는 시간이 필요하므로 Replication에 비해 쓰기 성능이 떨어진다.<br>

#### Replication
여러 개의 DB를 권한에 따라 수직적인 구조(Master - Slave)로 구축하는 방식<br>
비동기 방식으로 노드들 간의 데이터를 동기화한다.<br>
비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없으나, 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있다.<br>

<br>

### DB 튜닝
데이터베이스의 구조나 데이터베이스 자체, 운영체제 등을 조정하여 DB 시스템의 성능을 향상시키는 작업<br>
DB 설계 튜닝 -> DBMS 튜닝 -> SQL 튜닝 단계로 진행할 수 있다.<br>

#### 1단계 DB 설계 튜닝 (모델링 관점)
- 튜닝 방법<br>
데이터베이스 설계 단계에서 성능 고려하여 설계<br>
데이터 모델링, 인덱스 설계<br>
데이터 파일, 테이블 스페이스 설계 <br>
데이터베이스 용량 산정<br>

- 튜닝 사례<br>
반정규화, 분산 파일 배치

#### 2단계 DBMS 튜닝 (환경 관점)
- 튜닝 방법<br>
성능을 고려하여 메모리나 블록 크기 지정<br>
CPU, 메모리 I/O에 관한 관점<br>

- 튜닝 사례<br>
Buffer / Cache 크기

#### 3단계 SQL 튜닝 (APP 관점)
- 튜닝 방법<br>
SQL 작성 시 성능 고려<br>
Join, Indexing, SQL Execution Plan

- 튜닝 사례<br>
Hash / Join

