# 자료구조

데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조<br>
자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 동작들의 모임을 알고리즘이라고 한다.<br>

<br>

### Stack
세로로 된 바구니 구조<br>
먼저 넣은 자료가 마지막으로 나오는 First-In Last-Out (FILO) 구조이다.<br>
List로 구현하면 객체를 제거하는 작업이 필요하지만, Array로 구현하면 삭제할 필여 없이 index를 줄이고 초기화만 하면 되므로 Array로 구현하는 것이 좋다.<br>

<br>

### Queue
가로로 된 통 구조<br>
먼저 넣은 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조이다.<br>
Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요하지만, List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 Linked List로 구현하는 것이 좋다.<br>

<br>

### Tree
정점 및 간선을 이용한 사이클을 이루지 않는 그래프 형태<br>
계층이 있는 데이터를 표현하기에 적합하다.<br>

<br>

### Heap
최댓값 / 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조<br>
각 노드의 키값이 자식의 키값보다 작지 않거나 (최대힙) 자식의 키값보다 크지 않은 (최소힙) 완전 이진트리이다.<br>

<br>

### 우선순위 큐
가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조<br>
우선순위 큐를 구현하기 위해서 일반적으로 Heap을 사용하며, Heap은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logN)이다.<br>

<br>

### 해시 테이블
(Key, Value)로 데이터를 저장하는 자료구조<br>
빠른 데이터 검색이 필요할 때 유용하며, Key에 해시함수를 적용해 고유한 index를 생성하여 해당 index에 저장된 값을 꺼내오는 구조이다.<br>
고유한 index로 값을 조회하므로 평균적으로 O(1)의 시간복잡도를 가진다.<br>
해시의 index값이 충돌한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 떄문에 O(N)까지 증가할 수 있다.<br>

<br>

### ArrayList
데이터들이 순서대로 늘어선 배열의 형태<br>
원하는 데이터에 무작위 접근이 가능하다.<br>
리스트의 크기가 제한되어 있고, 리스트의 크기를 재조정하는 것은 많은 연산이 필요하다.<br>
데이터의 추가 및 삭제를 위해서는 임시 배열을 생성하고 복제해야 하므로 시간이 오래 걸린다.<br>

<br>

### LinkedList
리스트의 크기에 상관 없이 데이터를 추가할 수 있다.<br>
데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.<br>
무작위 접근이 불가능하며, 순차 접근만 가능하다.<br>

<br>

### AVL Tree
한 쪽으로 값이 치우치는 이진 탐색 트리(BST, Binary Search Tree)의 한계를 보완하기 위해 만들어진 균형 잡힌 이진 트리로, 항상 좌/우 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행한다.<br>

<br>

### Red-Black Tree
모든 노드를 붉은색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않도록 관리된다.<br>
